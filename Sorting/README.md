This folder contains samples and explanations regarding how sorting is done and 
how can sorting be used in solving problems.

# Sortings

## insert sort and merge sort

Insert sort in some sense is a special merge sort. It is merging a sorted list (generated by previous 
insertions) with a new list of a single element (thus also a sorted list)

Use an example of sorting four elements in a list. Here is the comparison

| insert sort | merge sort|
|---|---|
|merge [e1, e2] | merge [e1, e2]
|merge [e1, e2], [e3] | merge [e2, e3]|
|merge [e1, e2, e3], [e4] | merge [e1, e2], [e3, e4]|

We can see that the last one is an O(n) for both. For the insert sort, the worse case scenario is that 
e4 is the largest. So e4 ends up comparing with all the elements except itself. So (n-1) comparisons. 
For the merge sort, we can think about it from the return list point of view. Each time
we compare, we write an element into the return list. The return list is the final sorted list, 
so the length is n. So we need to do at most n comparison. It is also an O(n).

We can see from the table, the first step is the same, the last step is the same, but for the second step,
merge sort saves time.

Of course, the insert sort can be improved by binary search. 

# How to use sorting to solve problems

## What to sort

### events with different times
A meeting/activity has start time and end time. When we need to handle a list of meetings/activities, 
in general it is better to sort them.

We can sort them according to the end time. As shown in Greedy Algorithm. The activity selection 
example sorts all the activities using the end time. The key point is that the quicker it ends, 
the more time left to allocate new activities. Here only the number of activities matters, the total time
spent in activities doesn't matter.

We can sort them according to the start time, as shown in the MeetingRoom example of Heap, and then keep
a heap of the end time. Then we can compare the next starting meeting with the first ending meeting.

### sort the combination of some data
As shown in [FunGame](../AdvDesign/DynamicProgramming/GameTheory/FunGame.py), what matters is the
sum of cards from both players. We sort the sum.

Here a heap is used to maintain the sorted list.

## Special sorting

### find the kth largest/smallest element
Quick sort is good for this. Since the pivot holds its position during quick sort, once we find the
pivot location that matches k, we can stop there.

The other way to find the kth element is to use a heap, to keep things sorted

### heap
Heap is an efficient way to keep a dynamically changing list sorted.

#### kth element
To find max or min of a list, we just need to keep the current min and max, and update it as we
go though the list.

To find the kth element, we then need a heap of size k. Update the heap as we go through the list.

#### merge k sorted lists
Keep the top elements in all k sorted lists in a size-k heap. 
Pop the smallest into the return list, and read one more for the same sorted list. 

Special trick for python, heap can be used to sort tuples.

 

